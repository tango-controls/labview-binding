// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __corbaidl_defs_hh__
#define __corbaidl_defs_hh__

#ifndef __CORBA_mIDLType__
#define __CORBA_mIDLType__
class IDLType;
class _objref_IDLType;
class _impl_IDLType;

typedef _objref_IDLType* IDLType_ptr;
typedef IDLType_ptr IDLTypeRef;

class IDLType_Helper {
public:
  typedef IDLType_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IDLType, IDLType_Helper> IDLType_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IDLType,IDLType_Helper > IDLType_out;

#endif

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Identifier;

typedef char* Identifier;
typedef ::CORBA::String_var Identifier_var;
typedef ::CORBA::String_out Identifier_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RepositoryId;

typedef char* RepositoryId;
typedef ::CORBA::String_var RepositoryId_var;
typedef ::CORBA::String_out RepositoryId_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_VersionSpec;

typedef char* VersionSpec;
typedef ::CORBA::String_var VersionSpec_var;
typedef ::CORBA::String_out VersionSpec_out;

struct StructMember {
  typedef _CORBA_ConstrType_Variable_Var<StructMember> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef StructMember::_var_type StructMember_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< StructMember,StructMember_var > StructMember_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructMember;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructMemberSeq;

class StructMemberSeq_var;

class StructMemberSeq : public _CORBA_Unbounded_Sequence< StructMember >  {
public:
  typedef StructMemberSeq_var _var_type;
  inline StructMemberSeq() {}
  inline StructMemberSeq(const StructMemberSeq& _s)
    : _CORBA_Unbounded_Sequence< StructMember > (_s) {}

  inline StructMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< StructMember > (_max) {}
  inline StructMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, StructMember* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< StructMember > (_max, _len, _val, _rel) {}



  inline StructMemberSeq& operator = (const StructMemberSeq& _s) {
    _CORBA_Unbounded_Sequence< StructMember > ::operator=(_s);
    return *this;
  }
};

class StructMemberSeq_out;

class StructMemberSeq_var {
public:
  inline StructMemberSeq_var() : _pd_seq(0) {}
  inline StructMemberSeq_var(StructMemberSeq* _s) : _pd_seq(_s) {}
  inline StructMemberSeq_var(const StructMemberSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new StructMemberSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~StructMemberSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline StructMemberSeq_var& operator = (StructMemberSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline StructMemberSeq_var& operator = (const StructMemberSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new StructMemberSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline StructMember& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline StructMemberSeq* operator -> () { return _pd_seq; }
  inline const StructMemberSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator StructMemberSeq& () const { return *_pd_seq; }
#else
  inline operator const StructMemberSeq& () const { return *_pd_seq; }
  inline operator StructMemberSeq& () { return *_pd_seq; }
#endif
    
  inline const StructMemberSeq& in() const { return *_pd_seq; }
  inline StructMemberSeq&       inout()    { return *_pd_seq; }
  inline StructMemberSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline StructMemberSeq* _retn() { StructMemberSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class StructMemberSeq_out;
  
private:
  StructMemberSeq* _pd_seq;
};

class StructMemberSeq_out {
public:
  inline StructMemberSeq_out(StructMemberSeq*& _s) : _data(_s) { _data = 0; }
  inline StructMemberSeq_out(StructMemberSeq_var& _s)
    : _data(_s._pd_seq) { _s = (StructMemberSeq*) 0; }
  inline StructMemberSeq_out(const StructMemberSeq_out& _s) : _data(_s._data) {}
  inline StructMemberSeq_out& operator = (const StructMemberSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline StructMemberSeq_out& operator = (StructMemberSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator StructMemberSeq*&()  { return _data; }
  inline StructMemberSeq*& ptr()       { return _data; }
  inline StructMemberSeq* operator->() { return _data; }

  inline StructMember& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  StructMemberSeq*& _data;

private:
  StructMemberSeq_out();
  StructMemberSeq_out& operator=(const StructMemberSeq_var&);
};

struct UnionMember {
  typedef _CORBA_ConstrType_Variable_Var<UnionMember> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::Any label;

  ::CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef UnionMember::_var_type UnionMember_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< UnionMember,UnionMember_var > UnionMember_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnionMember;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnionMemberSeq;

class UnionMemberSeq_var;

class UnionMemberSeq : public _CORBA_Unbounded_Sequence< UnionMember >  {
public:
  typedef UnionMemberSeq_var _var_type;
  inline UnionMemberSeq() {}
  inline UnionMemberSeq(const UnionMemberSeq& _s)
    : _CORBA_Unbounded_Sequence< UnionMember > (_s) {}

  inline UnionMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< UnionMember > (_max) {}
  inline UnionMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, UnionMember* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< UnionMember > (_max, _len, _val, _rel) {}



  inline UnionMemberSeq& operator = (const UnionMemberSeq& _s) {
    _CORBA_Unbounded_Sequence< UnionMember > ::operator=(_s);
    return *this;
  }
};

class UnionMemberSeq_out;

class UnionMemberSeq_var {
public:
  inline UnionMemberSeq_var() : _pd_seq(0) {}
  inline UnionMemberSeq_var(UnionMemberSeq* _s) : _pd_seq(_s) {}
  inline UnionMemberSeq_var(const UnionMemberSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new UnionMemberSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~UnionMemberSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline UnionMemberSeq_var& operator = (UnionMemberSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline UnionMemberSeq_var& operator = (const UnionMemberSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new UnionMemberSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline UnionMember& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline UnionMemberSeq* operator -> () { return _pd_seq; }
  inline const UnionMemberSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator UnionMemberSeq& () const { return *_pd_seq; }
#else
  inline operator const UnionMemberSeq& () const { return *_pd_seq; }
  inline operator UnionMemberSeq& () { return *_pd_seq; }
#endif
    
  inline const UnionMemberSeq& in() const { return *_pd_seq; }
  inline UnionMemberSeq&       inout()    { return *_pd_seq; }
  inline UnionMemberSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline UnionMemberSeq* _retn() { UnionMemberSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class UnionMemberSeq_out;
  
private:
  UnionMemberSeq* _pd_seq;
};

class UnionMemberSeq_out {
public:
  inline UnionMemberSeq_out(UnionMemberSeq*& _s) : _data(_s) { _data = 0; }
  inline UnionMemberSeq_out(UnionMemberSeq_var& _s)
    : _data(_s._pd_seq) { _s = (UnionMemberSeq*) 0; }
  inline UnionMemberSeq_out(const UnionMemberSeq_out& _s) : _data(_s._data) {}
  inline UnionMemberSeq_out& operator = (const UnionMemberSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline UnionMemberSeq_out& operator = (UnionMemberSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator UnionMemberSeq*&()  { return _data; }
  inline UnionMemberSeq*& ptr()       { return _data; }
  inline UnionMemberSeq* operator->() { return _data; }

  inline UnionMember& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  UnionMemberSeq*& _data;

private:
  UnionMemberSeq_out();
  UnionMemberSeq_out& operator=(const UnionMemberSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EnumMemberSeq;

class EnumMemberSeq_var;

class EnumMemberSeq : public _CORBA_Unbounded_Sequence_String {
public:
  typedef EnumMemberSeq_var _var_type;
  inline EnumMemberSeq() {}
  inline EnumMemberSeq(const EnumMemberSeq& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline EnumMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline EnumMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline EnumMemberSeq& operator = (const EnumMemberSeq& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class EnumMemberSeq_out;

class EnumMemberSeq_var {
public:
  inline EnumMemberSeq_var() : _pd_seq(0) {}
  inline EnumMemberSeq_var(EnumMemberSeq* _s) : _pd_seq(_s) {}
  inline EnumMemberSeq_var(const EnumMemberSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new EnumMemberSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~EnumMemberSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline EnumMemberSeq_var& operator = (EnumMemberSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline EnumMemberSeq_var& operator = (const EnumMemberSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new EnumMemberSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline EnumMemberSeq* operator -> () { return _pd_seq; }
  inline const EnumMemberSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator EnumMemberSeq& () const { return *_pd_seq; }
#else
  inline operator const EnumMemberSeq& () const { return *_pd_seq; }
  inline operator EnumMemberSeq& () { return *_pd_seq; }
#endif
    
  inline const EnumMemberSeq& in() const { return *_pd_seq; }
  inline EnumMemberSeq&       inout()    { return *_pd_seq; }
  inline EnumMemberSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline EnumMemberSeq* _retn() { EnumMemberSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class EnumMemberSeq_out;
  
private:
  EnumMemberSeq* _pd_seq;
};

class EnumMemberSeq_out {
public:
  inline EnumMemberSeq_out(EnumMemberSeq*& _s) : _data(_s) { _data = 0; }
  inline EnumMemberSeq_out(EnumMemberSeq_var& _s)
    : _data(_s._pd_seq) { _s = (EnumMemberSeq*) 0; }
  inline EnumMemberSeq_out(const EnumMemberSeq_out& _s) : _data(_s._data) {}
  inline EnumMemberSeq_out& operator = (const EnumMemberSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline EnumMemberSeq_out& operator = (EnumMemberSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator EnumMemberSeq*&()  { return _data; }
  inline EnumMemberSeq*& ptr()       { return _data; }
  inline EnumMemberSeq* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  EnumMemberSeq*& _data;

private:
  EnumMemberSeq_out();
  EnumMemberSeq_out& operator=(const EnumMemberSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Visibility;

typedef ::CORBA::Short Visibility;
typedef ::CORBA::Short_out Visibility_out;

_CORBA_MODULE_VARINT const ::CORBA::Short PRIVATE_MEMBER _init_in_decl_( = 0 );

_CORBA_MODULE_VARINT const ::CORBA::Short PUBLIC_MEMBER _init_in_decl_( = 1 );

struct ValueMember {
  typedef _CORBA_ConstrType_Variable_Var<ValueMember> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  ::CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;

  Visibility access;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ValueMember::_var_type ValueMember_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ValueMember,ValueMember_var > ValueMember_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueMember;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueMemberSeq;

class ValueMemberSeq_var;

class ValueMemberSeq : public _CORBA_Unbounded_Sequence< ValueMember >  {
public:
  typedef ValueMemberSeq_var _var_type;
  inline ValueMemberSeq() {}
  inline ValueMemberSeq(const ValueMemberSeq& _s)
    : _CORBA_Unbounded_Sequence< ValueMember > (_s) {}

  inline ValueMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< ValueMember > (_max) {}
  inline ValueMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, ValueMember* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< ValueMember > (_max, _len, _val, _rel) {}



  inline ValueMemberSeq& operator = (const ValueMemberSeq& _s) {
    _CORBA_Unbounded_Sequence< ValueMember > ::operator=(_s);
    return *this;
  }
};

class ValueMemberSeq_out;

class ValueMemberSeq_var {
public:
  inline ValueMemberSeq_var() : _pd_seq(0) {}
  inline ValueMemberSeq_var(ValueMemberSeq* _s) : _pd_seq(_s) {}
  inline ValueMemberSeq_var(const ValueMemberSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ValueMemberSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ValueMemberSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ValueMemberSeq_var& operator = (ValueMemberSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ValueMemberSeq_var& operator = (const ValueMemberSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ValueMemberSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ValueMember& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ValueMemberSeq* operator -> () { return _pd_seq; }
  inline const ValueMemberSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ValueMemberSeq& () const { return *_pd_seq; }
#else
  inline operator const ValueMemberSeq& () const { return *_pd_seq; }
  inline operator ValueMemberSeq& () { return *_pd_seq; }
#endif
    
  inline const ValueMemberSeq& in() const { return *_pd_seq; }
  inline ValueMemberSeq&       inout()    { return *_pd_seq; }
  inline ValueMemberSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ValueMemberSeq* _retn() { ValueMemberSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ValueMemberSeq_out;
  
private:
  ValueMemberSeq* _pd_seq;
};

class ValueMemberSeq_out {
public:
  inline ValueMemberSeq_out(ValueMemberSeq*& _s) : _data(_s) { _data = 0; }
  inline ValueMemberSeq_out(ValueMemberSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ValueMemberSeq*) 0; }
  inline ValueMemberSeq_out(const ValueMemberSeq_out& _s) : _data(_s._data) {}
  inline ValueMemberSeq_out& operator = (const ValueMemberSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ValueMemberSeq_out& operator = (ValueMemberSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ValueMemberSeq*&()  { return _data; }
  inline ValueMemberSeq*& ptr()       { return _data; }
  inline ValueMemberSeq* operator->() { return _data; }

  inline ValueMember& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ValueMemberSeq*& _data;

private:
  ValueMemberSeq_out();
  ValueMemberSeq_out& operator=(const ValueMemberSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AnySeq;

class AnySeq_var;

class AnySeq : public _CORBA_Unbounded_Sequence< ::CORBA::Any >  {
public:
  typedef AnySeq_var _var_type;
  inline AnySeq() {}
  inline AnySeq(const AnySeq& _s)
    : _CORBA_Unbounded_Sequence< ::CORBA::Any > (_s) {}

  inline AnySeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< ::CORBA::Any > (_max) {}
  inline AnySeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Any* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< ::CORBA::Any > (_max, _len, _val, _rel) {}



  inline AnySeq& operator = (const AnySeq& _s) {
    _CORBA_Unbounded_Sequence< ::CORBA::Any > ::operator=(_s);
    return *this;
  }
};

class AnySeq_out;

class AnySeq_var {
public:
  inline AnySeq_var() : _pd_seq(0) {}
  inline AnySeq_var(AnySeq* _s) : _pd_seq(_s) {}
  inline AnySeq_var(const AnySeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new AnySeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~AnySeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline AnySeq_var& operator = (AnySeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline AnySeq_var& operator = (const AnySeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new AnySeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Any& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline AnySeq* operator -> () { return _pd_seq; }
  inline const AnySeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator AnySeq& () const { return *_pd_seq; }
#else
  inline operator const AnySeq& () const { return *_pd_seq; }
  inline operator AnySeq& () { return *_pd_seq; }
#endif
    
  inline const AnySeq& in() const { return *_pd_seq; }
  inline AnySeq&       inout()    { return *_pd_seq; }
  inline AnySeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline AnySeq* _retn() { AnySeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class AnySeq_out;
  
private:
  AnySeq* _pd_seq;
};

class AnySeq_out {
public:
  inline AnySeq_out(AnySeq*& _s) : _data(_s) { _data = 0; }
  inline AnySeq_out(AnySeq_var& _s)
    : _data(_s._pd_seq) { _s = (AnySeq*) 0; }
  inline AnySeq_out(const AnySeq_out& _s) : _data(_s._data) {}
  inline AnySeq_out& operator = (const AnySeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline AnySeq_out& operator = (AnySeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator AnySeq*&()  { return _data; }
  inline AnySeq*& ptr()       { return _data; }
  inline AnySeq* operator->() { return _data; }

  inline ::CORBA::Any& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  AnySeq*& _data;

private:
  AnySeq_out();
  AnySeq_out& operator=(const AnySeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BooleanSeq;

class BooleanSeq_var;

class BooleanSeq : public _CORBA_Unbounded_Sequence_Boolean {
public:
  typedef BooleanSeq_var _var_type;
  inline BooleanSeq() {}
  inline BooleanSeq(const BooleanSeq& _s)
    : _CORBA_Unbounded_Sequence_Boolean(_s) {}

  inline BooleanSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_Boolean(_max) {}
  inline BooleanSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Boolean* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_Boolean(_max, _len, _val, _rel) {}



  inline BooleanSeq& operator = (const BooleanSeq& _s) {
    _CORBA_Unbounded_Sequence_Boolean::operator=(_s);
    return *this;
  }
};

class BooleanSeq_out;

class BooleanSeq_var {
public:
  inline BooleanSeq_var() : _pd_seq(0) {}
  inline BooleanSeq_var(BooleanSeq* _s) : _pd_seq(_s) {}
  inline BooleanSeq_var(const BooleanSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new BooleanSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~BooleanSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline BooleanSeq_var& operator = (BooleanSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline BooleanSeq_var& operator = (const BooleanSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new BooleanSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Boolean& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline BooleanSeq* operator -> () { return _pd_seq; }
  inline const BooleanSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator BooleanSeq& () const { return *_pd_seq; }
#else
  inline operator const BooleanSeq& () const { return *_pd_seq; }
  inline operator BooleanSeq& () { return *_pd_seq; }
#endif
    
  inline const BooleanSeq& in() const { return *_pd_seq; }
  inline BooleanSeq&       inout()    { return *_pd_seq; }
  inline BooleanSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline BooleanSeq* _retn() { BooleanSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class BooleanSeq_out;
  
private:
  BooleanSeq* _pd_seq;
};

class BooleanSeq_out {
public:
  inline BooleanSeq_out(BooleanSeq*& _s) : _data(_s) { _data = 0; }
  inline BooleanSeq_out(BooleanSeq_var& _s)
    : _data(_s._pd_seq) { _s = (BooleanSeq*) 0; }
  inline BooleanSeq_out(const BooleanSeq_out& _s) : _data(_s._data) {}
  inline BooleanSeq_out& operator = (const BooleanSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline BooleanSeq_out& operator = (BooleanSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator BooleanSeq*&()  { return _data; }
  inline BooleanSeq*& ptr()       { return _data; }
  inline BooleanSeq* operator->() { return _data; }

  inline ::CORBA::Boolean& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  BooleanSeq*& _data;

private:
  BooleanSeq_out();
  BooleanSeq_out& operator=(const BooleanSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CharSeq;

class CharSeq_var;

class CharSeq : public _CORBA_Unbounded_Sequence_Char {
public:
  typedef CharSeq_var _var_type;
  inline CharSeq() {}
  inline CharSeq(const CharSeq& _s)
    : _CORBA_Unbounded_Sequence_Char(_s) {}

  inline CharSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_Char(_max) {}
  inline CharSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Char* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_Char(_max, _len, _val, _rel) {}



  inline CharSeq& operator = (const CharSeq& _s) {
    _CORBA_Unbounded_Sequence_Char::operator=(_s);
    return *this;
  }
};

class CharSeq_out;

class CharSeq_var {
public:
  inline CharSeq_var() : _pd_seq(0) {}
  inline CharSeq_var(CharSeq* _s) : _pd_seq(_s) {}
  inline CharSeq_var(const CharSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new CharSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~CharSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline CharSeq_var& operator = (CharSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline CharSeq_var& operator = (const CharSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new CharSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Char& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline CharSeq* operator -> () { return _pd_seq; }
  inline const CharSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator CharSeq& () const { return *_pd_seq; }
#else
  inline operator const CharSeq& () const { return *_pd_seq; }
  inline operator CharSeq& () { return *_pd_seq; }
#endif
    
  inline const CharSeq& in() const { return *_pd_seq; }
  inline CharSeq&       inout()    { return *_pd_seq; }
  inline CharSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline CharSeq* _retn() { CharSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class CharSeq_out;
  
private:
  CharSeq* _pd_seq;
};

class CharSeq_out {
public:
  inline CharSeq_out(CharSeq*& _s) : _data(_s) { _data = 0; }
  inline CharSeq_out(CharSeq_var& _s)
    : _data(_s._pd_seq) { _s = (CharSeq*) 0; }
  inline CharSeq_out(const CharSeq_out& _s) : _data(_s._data) {}
  inline CharSeq_out& operator = (const CharSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline CharSeq_out& operator = (CharSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator CharSeq*&()  { return _data; }
  inline CharSeq*& ptr()       { return _data; }
  inline CharSeq* operator->() { return _data; }

  inline ::CORBA::Char& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  CharSeq*& _data;

private:
  CharSeq_out();
  CharSeq_out& operator=(const CharSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WCharSeq;

class WCharSeq_var;

class WCharSeq : public _CORBA_Unbounded_Sequence_WChar {
public:
  typedef WCharSeq_var _var_type;
  inline WCharSeq() {}
  inline WCharSeq(const WCharSeq& _s)
    : _CORBA_Unbounded_Sequence_WChar(_s) {}

  inline WCharSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_WChar(_max) {}
  inline WCharSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::WChar* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_WChar(_max, _len, _val, _rel) {}



  inline WCharSeq& operator = (const WCharSeq& _s) {
    _CORBA_Unbounded_Sequence_WChar::operator=(_s);
    return *this;
  }
};

class WCharSeq_out;

class WCharSeq_var {
public:
  inline WCharSeq_var() : _pd_seq(0) {}
  inline WCharSeq_var(WCharSeq* _s) : _pd_seq(_s) {}
  inline WCharSeq_var(const WCharSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new WCharSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~WCharSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline WCharSeq_var& operator = (WCharSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline WCharSeq_var& operator = (const WCharSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new WCharSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::WChar& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline WCharSeq* operator -> () { return _pd_seq; }
  inline const WCharSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator WCharSeq& () const { return *_pd_seq; }
#else
  inline operator const WCharSeq& () const { return *_pd_seq; }
  inline operator WCharSeq& () { return *_pd_seq; }
#endif
    
  inline const WCharSeq& in() const { return *_pd_seq; }
  inline WCharSeq&       inout()    { return *_pd_seq; }
  inline WCharSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline WCharSeq* _retn() { WCharSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class WCharSeq_out;
  
private:
  WCharSeq* _pd_seq;
};

class WCharSeq_out {
public:
  inline WCharSeq_out(WCharSeq*& _s) : _data(_s) { _data = 0; }
  inline WCharSeq_out(WCharSeq_var& _s)
    : _data(_s._pd_seq) { _s = (WCharSeq*) 0; }
  inline WCharSeq_out(const WCharSeq_out& _s) : _data(_s._data) {}
  inline WCharSeq_out& operator = (const WCharSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline WCharSeq_out& operator = (WCharSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator WCharSeq*&()  { return _data; }
  inline WCharSeq*& ptr()       { return _data; }
  inline WCharSeq* operator->() { return _data; }

  inline ::CORBA::WChar& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  WCharSeq*& _data;

private:
  WCharSeq_out();
  WCharSeq_out& operator=(const WCharSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OctetSeq;

class OctetSeq_var;

class OctetSeq : public _CORBA_Unbounded_Sequence_Octet {
public:
  typedef OctetSeq_var _var_type;
  inline OctetSeq() {}
  inline OctetSeq(const OctetSeq& _s)
    : _CORBA_Unbounded_Sequence_Octet(_s) {}

  inline OctetSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_Octet(_max) {}
  inline OctetSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}



  inline OctetSeq& operator = (const OctetSeq& _s) {
    _CORBA_Unbounded_Sequence_Octet::operator=(_s);
    return *this;
  }
};

class OctetSeq_out;

class OctetSeq_var {
public:
  inline OctetSeq_var() : _pd_seq(0) {}
  inline OctetSeq_var(OctetSeq* _s) : _pd_seq(_s) {}
  inline OctetSeq_var(const OctetSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new OctetSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~OctetSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline OctetSeq_var& operator = (OctetSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline OctetSeq_var& operator = (const OctetSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new OctetSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline OctetSeq* operator -> () { return _pd_seq; }
  inline const OctetSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator OctetSeq& () const { return *_pd_seq; }
#else
  inline operator const OctetSeq& () const { return *_pd_seq; }
  inline operator OctetSeq& () { return *_pd_seq; }
#endif
    
  inline const OctetSeq& in() const { return *_pd_seq; }
  inline OctetSeq&       inout()    { return *_pd_seq; }
  inline OctetSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline OctetSeq* _retn() { OctetSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class OctetSeq_out;
  
private:
  OctetSeq* _pd_seq;
};

class OctetSeq_out {
public:
  inline OctetSeq_out(OctetSeq*& _s) : _data(_s) { _data = 0; }
  inline OctetSeq_out(OctetSeq_var& _s)
    : _data(_s._pd_seq) { _s = (OctetSeq*) 0; }
  inline OctetSeq_out(const OctetSeq_out& _s) : _data(_s._data) {}
  inline OctetSeq_out& operator = (const OctetSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline OctetSeq_out& operator = (OctetSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator OctetSeq*&()  { return _data; }
  inline OctetSeq*& ptr()       { return _data; }
  inline OctetSeq* operator->() { return _data; }

  inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  OctetSeq*& _data;

private:
  OctetSeq_out();
  OctetSeq_out& operator=(const OctetSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ShortSeq;

class ShortSeq_var;

class ShortSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 >  {
public:
  typedef ShortSeq_var _var_type;
  inline ShortSeq() {}
  inline ShortSeq(const ShortSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_s) {}

  inline ShortSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max) {}
  inline ShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Short* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max, _len, _val, _rel) {}



  inline ShortSeq& operator = (const ShortSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > ::operator=(_s);
    return *this;
  }
};

class ShortSeq_out;

class ShortSeq_var {
public:
  inline ShortSeq_var() : _pd_seq(0) {}
  inline ShortSeq_var(ShortSeq* _s) : _pd_seq(_s) {}
  inline ShortSeq_var(const ShortSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ShortSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ShortSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ShortSeq_var& operator = (ShortSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ShortSeq_var& operator = (const ShortSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ShortSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Short& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ShortSeq* operator -> () { return _pd_seq; }
  inline const ShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ShortSeq& () const { return *_pd_seq; }
#else
  inline operator const ShortSeq& () const { return *_pd_seq; }
  inline operator ShortSeq& () { return *_pd_seq; }
#endif
    
  inline const ShortSeq& in() const { return *_pd_seq; }
  inline ShortSeq&       inout()    { return *_pd_seq; }
  inline ShortSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ShortSeq* _retn() { ShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ShortSeq_out;
  
private:
  ShortSeq* _pd_seq;
};

class ShortSeq_out {
public:
  inline ShortSeq_out(ShortSeq*& _s) : _data(_s) { _data = 0; }
  inline ShortSeq_out(ShortSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ShortSeq*) 0; }
  inline ShortSeq_out(const ShortSeq_out& _s) : _data(_s._data) {}
  inline ShortSeq_out& operator = (const ShortSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ShortSeq_out& operator = (ShortSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ShortSeq*&()  { return _data; }
  inline ShortSeq*& ptr()       { return _data; }
  inline ShortSeq* operator->() { return _data; }

  inline ::CORBA::Short& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ShortSeq*& _data;

private:
  ShortSeq_out();
  ShortSeq_out& operator=(const ShortSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UShortSeq;

class UShortSeq_var;

class UShortSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
public:
  typedef UShortSeq_var _var_type;
  inline UShortSeq() {}
  inline UShortSeq(const UShortSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

  inline UShortSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
  inline UShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}



  inline UShortSeq& operator = (const UShortSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
    return *this;
  }
};

class UShortSeq_out;

class UShortSeq_var {
public:
  inline UShortSeq_var() : _pd_seq(0) {}
  inline UShortSeq_var(UShortSeq* _s) : _pd_seq(_s) {}
  inline UShortSeq_var(const UShortSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new UShortSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~UShortSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline UShortSeq_var& operator = (UShortSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline UShortSeq_var& operator = (const UShortSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new UShortSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline UShortSeq* operator -> () { return _pd_seq; }
  inline const UShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator UShortSeq& () const { return *_pd_seq; }
#else
  inline operator const UShortSeq& () const { return *_pd_seq; }
  inline operator UShortSeq& () { return *_pd_seq; }
#endif
    
  inline const UShortSeq& in() const { return *_pd_seq; }
  inline UShortSeq&       inout()    { return *_pd_seq; }
  inline UShortSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline UShortSeq* _retn() { UShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class UShortSeq_out;
  
private:
  UShortSeq* _pd_seq;
};

class UShortSeq_out {
public:
  inline UShortSeq_out(UShortSeq*& _s) : _data(_s) { _data = 0; }
  inline UShortSeq_out(UShortSeq_var& _s)
    : _data(_s._pd_seq) { _s = (UShortSeq*) 0; }
  inline UShortSeq_out(const UShortSeq_out& _s) : _data(_s._data) {}
  inline UShortSeq_out& operator = (const UShortSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline UShortSeq_out& operator = (UShortSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator UShortSeq*&()  { return _data; }
  inline UShortSeq*& ptr()       { return _data; }
  inline UShortSeq* operator->() { return _data; }

  inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  UShortSeq*& _data;

private:
  UShortSeq_out();
  UShortSeq_out& operator=(const UShortSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LongSeq;

class LongSeq_var;

class LongSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
public:
  typedef LongSeq_var _var_type;
  inline LongSeq() {}
  inline LongSeq(const LongSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

  inline LongSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
  inline LongSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}



  inline LongSeq& operator = (const LongSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
    return *this;
  }
};

class LongSeq_out;

class LongSeq_var {
public:
  inline LongSeq_var() : _pd_seq(0) {}
  inline LongSeq_var(LongSeq* _s) : _pd_seq(_s) {}
  inline LongSeq_var(const LongSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new LongSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~LongSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline LongSeq_var& operator = (LongSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline LongSeq_var& operator = (const LongSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new LongSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline LongSeq* operator -> () { return _pd_seq; }
  inline const LongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator LongSeq& () const { return *_pd_seq; }
#else
  inline operator const LongSeq& () const { return *_pd_seq; }
  inline operator LongSeq& () { return *_pd_seq; }
#endif
    
  inline const LongSeq& in() const { return *_pd_seq; }
  inline LongSeq&       inout()    { return *_pd_seq; }
  inline LongSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline LongSeq* _retn() { LongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class LongSeq_out;
  
private:
  LongSeq* _pd_seq;
};

class LongSeq_out {
public:
  inline LongSeq_out(LongSeq*& _s) : _data(_s) { _data = 0; }
  inline LongSeq_out(LongSeq_var& _s)
    : _data(_s._pd_seq) { _s = (LongSeq*) 0; }
  inline LongSeq_out(const LongSeq_out& _s) : _data(_s._data) {}
  inline LongSeq_out& operator = (const LongSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline LongSeq_out& operator = (LongSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator LongSeq*&()  { return _data; }
  inline LongSeq*& ptr()       { return _data; }
  inline LongSeq* operator->() { return _data; }

  inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  LongSeq*& _data;

private:
  LongSeq_out();
  LongSeq_out& operator=(const LongSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ULongSeq;

class ULongSeq_var;

class ULongSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 >  {
public:
  typedef ULongSeq_var _var_type;
  inline ULongSeq() {}
  inline ULongSeq(const ULongSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_s) {}

  inline ULongSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max) {}
  inline ULongSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULong* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max, _len, _val, _rel) {}



  inline ULongSeq& operator = (const ULongSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > ::operator=(_s);
    return *this;
  }
};

class ULongSeq_out;

class ULongSeq_var {
public:
  inline ULongSeq_var() : _pd_seq(0) {}
  inline ULongSeq_var(ULongSeq* _s) : _pd_seq(_s) {}
  inline ULongSeq_var(const ULongSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ULongSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ULongSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ULongSeq_var& operator = (ULongSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ULongSeq_var& operator = (const ULongSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ULongSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::ULong& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ULongSeq* operator -> () { return _pd_seq; }
  inline const ULongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ULongSeq& () const { return *_pd_seq; }
#else
  inline operator const ULongSeq& () const { return *_pd_seq; }
  inline operator ULongSeq& () { return *_pd_seq; }
#endif
    
  inline const ULongSeq& in() const { return *_pd_seq; }
  inline ULongSeq&       inout()    { return *_pd_seq; }
  inline ULongSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ULongSeq* _retn() { ULongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ULongSeq_out;
  
private:
  ULongSeq* _pd_seq;
};

class ULongSeq_out {
public:
  inline ULongSeq_out(ULongSeq*& _s) : _data(_s) { _data = 0; }
  inline ULongSeq_out(ULongSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ULongSeq*) 0; }
  inline ULongSeq_out(const ULongSeq_out& _s) : _data(_s._data) {}
  inline ULongSeq_out& operator = (const ULongSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ULongSeq_out& operator = (ULongSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ULongSeq*&()  { return _data; }
  inline ULongSeq*& ptr()       { return _data; }
  inline ULongSeq* operator->() { return _data; }

  inline ::CORBA::ULong& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ULongSeq*& _data;

private:
  ULongSeq_out();
  ULongSeq_out& operator=(const ULongSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LongLongSeq;

class LongLongSeq_var;

class LongLongSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 >  {
public:
  typedef LongLongSeq_var _var_type;
  inline LongLongSeq() {}
  inline LongLongSeq(const LongLongSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_s) {}

  inline LongLongSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max) {}
  inline LongLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::LongLong* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max, _len, _val, _rel) {}



  inline LongLongSeq& operator = (const LongLongSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > ::operator=(_s);
    return *this;
  }
};

class LongLongSeq_out;

class LongLongSeq_var {
public:
  inline LongLongSeq_var() : _pd_seq(0) {}
  inline LongLongSeq_var(LongLongSeq* _s) : _pd_seq(_s) {}
  inline LongLongSeq_var(const LongLongSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new LongLongSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~LongLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline LongLongSeq_var& operator = (LongLongSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline LongLongSeq_var& operator = (const LongLongSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new LongLongSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::LongLong& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline LongLongSeq* operator -> () { return _pd_seq; }
  inline const LongLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator LongLongSeq& () const { return *_pd_seq; }
#else
  inline operator const LongLongSeq& () const { return *_pd_seq; }
  inline operator LongLongSeq& () { return *_pd_seq; }
#endif
    
  inline const LongLongSeq& in() const { return *_pd_seq; }
  inline LongLongSeq&       inout()    { return *_pd_seq; }
  inline LongLongSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline LongLongSeq* _retn() { LongLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class LongLongSeq_out;
  
private:
  LongLongSeq* _pd_seq;
};

class LongLongSeq_out {
public:
  inline LongLongSeq_out(LongLongSeq*& _s) : _data(_s) { _data = 0; }
  inline LongLongSeq_out(LongLongSeq_var& _s)
    : _data(_s._pd_seq) { _s = (LongLongSeq*) 0; }
  inline LongLongSeq_out(const LongLongSeq_out& _s) : _data(_s._data) {}
  inline LongLongSeq_out& operator = (const LongLongSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline LongLongSeq_out& operator = (LongLongSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator LongLongSeq*&()  { return _data; }
  inline LongLongSeq*& ptr()       { return _data; }
  inline LongLongSeq* operator->() { return _data; }

  inline ::CORBA::LongLong& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  LongLongSeq*& _data;

private:
  LongLongSeq_out();
  LongLongSeq_out& operator=(const LongLongSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ULongLongSeq;

class ULongLongSeq_var;

class ULongLongSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 >  {
public:
  typedef ULongLongSeq_var _var_type;
  inline ULongLongSeq() {}
  inline ULongLongSeq(const ULongLongSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_s) {}

  inline ULongLongSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max) {}
  inline ULongLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULongLong* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max, _len, _val, _rel) {}



  inline ULongLongSeq& operator = (const ULongLongSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > ::operator=(_s);
    return *this;
  }
};

class ULongLongSeq_out;

class ULongLongSeq_var {
public:
  inline ULongLongSeq_var() : _pd_seq(0) {}
  inline ULongLongSeq_var(ULongLongSeq* _s) : _pd_seq(_s) {}
  inline ULongLongSeq_var(const ULongLongSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ULongLongSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ULongLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ULongLongSeq_var& operator = (ULongLongSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ULongLongSeq_var& operator = (const ULongLongSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ULongLongSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ULongLongSeq* operator -> () { return _pd_seq; }
  inline const ULongLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ULongLongSeq& () const { return *_pd_seq; }
#else
  inline operator const ULongLongSeq& () const { return *_pd_seq; }
  inline operator ULongLongSeq& () { return *_pd_seq; }
#endif
    
  inline const ULongLongSeq& in() const { return *_pd_seq; }
  inline ULongLongSeq&       inout()    { return *_pd_seq; }
  inline ULongLongSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ULongLongSeq* _retn() { ULongLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ULongLongSeq_out;
  
private:
  ULongLongSeq* _pd_seq;
};

class ULongLongSeq_out {
public:
  inline ULongLongSeq_out(ULongLongSeq*& _s) : _data(_s) { _data = 0; }
  inline ULongLongSeq_out(ULongLongSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ULongLongSeq*) 0; }
  inline ULongLongSeq_out(const ULongLongSeq_out& _s) : _data(_s._data) {}
  inline ULongLongSeq_out& operator = (const ULongLongSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ULongLongSeq_out& operator = (ULongLongSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ULongLongSeq*&()  { return _data; }
  inline ULongLongSeq*& ptr()       { return _data; }
  inline ULongLongSeq* operator->() { return _data; }

  inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ULongLongSeq*& _data;

private:
  ULongLongSeq_out();
  ULongLongSeq_out& operator=(const ULongLongSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FloatSeq;

class FloatSeq_var;

class FloatSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  {
public:
  typedef FloatSeq_var _var_type;
  inline FloatSeq() {}
  inline FloatSeq(const FloatSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_s) {}

  inline FloatSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max) {}
  inline FloatSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Float* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max, _len, _val, _rel) {}



  inline FloatSeq& operator = (const FloatSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > ::operator=(_s);
    return *this;
  }
};

class FloatSeq_out;

class FloatSeq_var {
public:
  inline FloatSeq_var() : _pd_seq(0) {}
  inline FloatSeq_var(FloatSeq* _s) : _pd_seq(_s) {}
  inline FloatSeq_var(const FloatSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new FloatSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~FloatSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline FloatSeq_var& operator = (FloatSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline FloatSeq_var& operator = (const FloatSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new FloatSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Float& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline FloatSeq* operator -> () { return _pd_seq; }
  inline const FloatSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator FloatSeq& () const { return *_pd_seq; }
#else
  inline operator const FloatSeq& () const { return *_pd_seq; }
  inline operator FloatSeq& () { return *_pd_seq; }
#endif
    
  inline const FloatSeq& in() const { return *_pd_seq; }
  inline FloatSeq&       inout()    { return *_pd_seq; }
  inline FloatSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline FloatSeq* _retn() { FloatSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class FloatSeq_out;
  
private:
  FloatSeq* _pd_seq;
};

class FloatSeq_out {
public:
  inline FloatSeq_out(FloatSeq*& _s) : _data(_s) { _data = 0; }
  inline FloatSeq_out(FloatSeq_var& _s)
    : _data(_s._pd_seq) { _s = (FloatSeq*) 0; }
  inline FloatSeq_out(const FloatSeq_out& _s) : _data(_s._data) {}
  inline FloatSeq_out& operator = (const FloatSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline FloatSeq_out& operator = (FloatSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator FloatSeq*&()  { return _data; }
  inline FloatSeq*& ptr()       { return _data; }
  inline FloatSeq* operator->() { return _data; }

  inline ::CORBA::Float& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  FloatSeq*& _data;

private:
  FloatSeq_out();
  FloatSeq_out& operator=(const FloatSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DoubleSeq;

class DoubleSeq_var;

class DoubleSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
public:
  typedef DoubleSeq_var _var_type;
  inline DoubleSeq() {}
  inline DoubleSeq(const DoubleSeq& _s)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

  inline DoubleSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
  inline DoubleSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}



  inline DoubleSeq& operator = (const DoubleSeq& _s) {
    _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
    return *this;
  }
};

class DoubleSeq_out;

class DoubleSeq_var {
public:
  inline DoubleSeq_var() : _pd_seq(0) {}
  inline DoubleSeq_var(DoubleSeq* _s) : _pd_seq(_s) {}
  inline DoubleSeq_var(const DoubleSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new DoubleSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~DoubleSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline DoubleSeq_var& operator = (DoubleSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline DoubleSeq_var& operator = (const DoubleSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new DoubleSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline DoubleSeq* operator -> () { return _pd_seq; }
  inline const DoubleSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator DoubleSeq& () const { return *_pd_seq; }
#else
  inline operator const DoubleSeq& () const { return *_pd_seq; }
  inline operator DoubleSeq& () { return *_pd_seq; }
#endif
    
  inline const DoubleSeq& in() const { return *_pd_seq; }
  inline DoubleSeq&       inout()    { return *_pd_seq; }
  inline DoubleSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline DoubleSeq* _retn() { DoubleSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class DoubleSeq_out;
  
private:
  DoubleSeq* _pd_seq;
};

class DoubleSeq_out {
public:
  inline DoubleSeq_out(DoubleSeq*& _s) : _data(_s) { _data = 0; }
  inline DoubleSeq_out(DoubleSeq_var& _s)
    : _data(_s._pd_seq) { _s = (DoubleSeq*) 0; }
  inline DoubleSeq_out(const DoubleSeq_out& _s) : _data(_s._data) {}
  inline DoubleSeq_out& operator = (const DoubleSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline DoubleSeq_out& operator = (DoubleSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator DoubleSeq*&()  { return _data; }
  inline DoubleSeq*& ptr()       { return _data; }
  inline DoubleSeq* operator->() { return _data; }

  inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  DoubleSeq*& _data;

private:
  DoubleSeq_out();
  DoubleSeq_out& operator=(const DoubleSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringSeq;

class StringSeq_var;

class StringSeq : public _CORBA_Unbounded_Sequence_String {
public:
  typedef StringSeq_var _var_type;
  inline StringSeq() {}
  inline StringSeq(const StringSeq& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline StringSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline StringSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline StringSeq& operator = (const StringSeq& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class StringSeq_out;

class StringSeq_var {
public:
  inline StringSeq_var() : _pd_seq(0) {}
  inline StringSeq_var(StringSeq* _s) : _pd_seq(_s) {}
  inline StringSeq_var(const StringSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new StringSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~StringSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline StringSeq_var& operator = (StringSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline StringSeq_var& operator = (const StringSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new StringSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline StringSeq* operator -> () { return _pd_seq; }
  inline const StringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator StringSeq& () const { return *_pd_seq; }
#else
  inline operator const StringSeq& () const { return *_pd_seq; }
  inline operator StringSeq& () { return *_pd_seq; }
#endif
    
  inline const StringSeq& in() const { return *_pd_seq; }
  inline StringSeq&       inout()    { return *_pd_seq; }
  inline StringSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline StringSeq* _retn() { StringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class StringSeq_out;
  
private:
  StringSeq* _pd_seq;
};

class StringSeq_out {
public:
  inline StringSeq_out(StringSeq*& _s) : _data(_s) { _data = 0; }
  inline StringSeq_out(StringSeq_var& _s)
    : _data(_s._pd_seq) { _s = (StringSeq*) 0; }
  inline StringSeq_out(const StringSeq_out& _s) : _data(_s._data) {}
  inline StringSeq_out& operator = (const StringSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline StringSeq_out& operator = (StringSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator StringSeq*&()  { return _data; }
  inline StringSeq*& ptr()       { return _data; }
  inline StringSeq* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  StringSeq*& _data;

private:
  StringSeq_out();
  StringSeq_out& operator=(const StringSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WStringSeq;

class WStringSeq_var;

class WStringSeq : public _CORBA_Unbounded_Sequence_WString {
public:
  typedef WStringSeq_var _var_type;
  inline WStringSeq() {}
  inline WStringSeq(const WStringSeq& _s)
    : _CORBA_Unbounded_Sequence_WString(_s) {}

  inline WStringSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_WString(_max) {}
  inline WStringSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::WChar** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_WString(_max, _len, _val, _rel) {}



  inline WStringSeq& operator = (const WStringSeq& _s) {
    _CORBA_Unbounded_Sequence_WString::operator=(_s);
    return *this;
  }
};

class WStringSeq_out;

class WStringSeq_var {
public:
  inline WStringSeq_var() : _pd_seq(0) {}
  inline WStringSeq_var(WStringSeq* _s) : _pd_seq(_s) {}
  inline WStringSeq_var(const WStringSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new WStringSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~WStringSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline WStringSeq_var& operator = (WStringSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline WStringSeq_var& operator = (const WStringSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new WStringSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_WString_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline WStringSeq* operator -> () { return _pd_seq; }
  inline const WStringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator WStringSeq& () const { return *_pd_seq; }
#else
  inline operator const WStringSeq& () const { return *_pd_seq; }
  inline operator WStringSeq& () { return *_pd_seq; }
#endif
    
  inline const WStringSeq& in() const { return *_pd_seq; }
  inline WStringSeq&       inout()    { return *_pd_seq; }
  inline WStringSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline WStringSeq* _retn() { WStringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class WStringSeq_out;
  
private:
  WStringSeq* _pd_seq;
};

class WStringSeq_out {
public:
  inline WStringSeq_out(WStringSeq*& _s) : _data(_s) { _data = 0; }
  inline WStringSeq_out(WStringSeq_var& _s)
    : _data(_s._pd_seq) { _s = (WStringSeq*) 0; }
  inline WStringSeq_out(const WStringSeq_out& _s) : _data(_s._data) {}
  inline WStringSeq_out& operator = (const WStringSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline WStringSeq_out& operator = (WStringSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator WStringSeq*&()  { return _data; }
  inline WStringSeq*& ptr()       { return _data; }
  inline WStringSeq* operator->() { return _data; }

  inline _CORBA_WString_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  WStringSeq*& _data;

private:
  WStringSeq_out();
  WStringSeq_out& operator=(const WStringSeq_var&);
};

#endif

